1. Extending functionality in nginx, with modules!2012-01-31
2. What is nginx?•The 2nd most used HTTP-server (Apache is 1st)•Asynchronous event-driven approach to request-handling.•Written in C•Readable source code!
3. What kind of modules do we have?•handler modules - they process a request and produce output•filter modules - they manipulate the output produced by a handler•load-balancers - they choose a backend server to send a request to, when more than one backend server is eligible
4. What will you learn through the course of thispresentation?•Step 0: Building Nginx (with a module)•Step 1: Create a stub http content module, aka "Hello, World"•Step 2: Update the module to use an external library for content creation•Step 3: Give your module its own configuration directives•Step 4: Fetching arguments from the URL
5. Lets get startedStep 0: Building Nginx (with a module)
6. Download & build# wget http://nginx.org/download/nginx-1.0.11.tar.gz# tar zxvf nginx-1.0.11.tar.gz# cd nginx-1.0.11.tar.gz# ./configure# makeStraight forward. No surprises there.
7. Building a third party moduleModules are statically linked, so adding a new module requiresa new nginx-build.# ./configure --add-module=$HOME/git/some_cool_module_I_found_somewhere_on_github# makeEasy. (Want more modules? --add-module can be added severaltimes)
8. This is boring, show me the code!Step 1: Create a stub http content module, aka "Hello, World"
9. Creating your own moduleA minimal HTTP module - lets call it "fun" - consists of adirectory with two files:configand a source filengx_http_fun_module.cA significant amount of the source-file will be stub-code.
10. The config fileIs sourced as a shell-script, and should set differentenvironment variables to help the build-system understandwhat to do.A minimal config-file for a module without any externaldependencies could look like this:ngx_addon_name=ngx_http_fun_moduleHTTP_MODULES="$HTTP_MODULES ngx_http_fun_module"NGX_ADDON_SRCS="$NGX_ADDON_SRCS $ngx_addon_dir/ngx_http_fun_module.c"
11. The source file (1)Include your headers.#include <ngx_config.h>#include <ngx_core.h>#include <ngx_http.h>Declare a handler.static char * ngx_http_fun(ngx_conf_t * cf, ngx_command_t * cmd, void * conf);Create our HTTP body.static u_char ngx_fun_string[] = "This is fun!";
12. How does nginx know about my configurationdirectives?Quoting the nginx source-code:struct ngx_command_s { ngx_str_t name; ngx_uint_t type; char * (* set)(ngx_conf_t * cf, ngx_command_t * cmd, void * conf); ngx_uint_t conf; ngx_uint_t offset; void * post;};#define ngx_null_command { ngx_null_string, 0, NULL, 0, 0, NULL }typedef struct ngx_command_s ngx_command_t;An array of ngx_command_ts, terminated by angx_null_command should be defined in your module.
13. Declaring the configuration parametersavailable by your moduleCreate a static array of the ngx_command_t-type, terminate itwith ngx_null_command. Populate it with the commandsavailable for your module.static ngx_command_t ngx_http_fun_commands[] = { { // Our command is named "fun": ngx_string("fun"), // The directive may be specified in the location-level of your nginx-config. // The directive does not take any arguments (NGX_CONF_NOARGS) NGX_HTTP_LOC_CONF|NGX_CONF_NOARGS, // A pointer to our handler-function. ngx_http_fun, // Were not using these two, theyre related to the configuration structures. 0, 0, // A pointer to a post-processing handler. Were not using any here. NULL }, ngx_null_command};
14. Declaring the module contextCreate a static ngx_http_module_t, populate all 8 elements withNULL.static ngx_http_module_t ngx_http_fun_module_ctx = { NULL, // preconfiguration NULL, // postconfiguration NULL, // create main configuration NULL, // init main configuration NULL, // create server configuration NULL, // merge server configuration NULL, // create location configuration NULL // merge location configuration};This is used to determine multiple levels of configuration, andgives you control over which directives beat which in a race.Our module does not use any configuration parameters otherthan "fun;", so we dont need any handlers.
15. Declaring the module description structureCreate a (not static) structure of type ngx_module_t, referencethe structures weve made like this:ngx_module_t ngx_http_fun_module = { NGX_MODULE_V1, &ngx_http_fun_module_ctx, // module context ngx_http_fun_commands, // module directives NGX_HTTP_MODULE, // module type NULL, // init master NULL, // init module NULL, // init process NULL, // init thread NULL, // exit thread NULL, // exit process NULL, // exit master NGX_MODULE_V1_PADDING};
16. Creating the actual handler (1)A static function that returns an ngx_int_t, and receives apointer to a ngx_http_request_t.static ngx_int_tngx_http_fun_handler(ngx_http_request_t * r){ ngx_int_t rc; ngx_buf_t * b; ngx_chain_t out;We use rc to store the return value of certain function calls.We use * b to store our buffer pointer.out is the buffer chain.
17. Creating the actual handler (2)A simple test of the kind of request were receiving.// we response to GET and HEAD requests onlyif (!(r->method & (NGX_HTTP_GET|NGX_HTTP_HEAD))) { return NGX_HTTP_NOT_ALLOWED;}
18. Creating the actual handler (3)The request-body is useful if were dealing with POST. Werenot.// discard request body, since we dont need it hererc = ngx_http_discard_request_body(r);if (rc != NGX_OK) { return rc;}This attempts to detach the request body from the request. Itsan optimization.
19. Creating the actual handler (4)Setting the content-type is important --// set the Content-type headerr->headers_out.content_type_len = sizeof("text/html") - 1;r->headers_out.content_type.len = sizeof("text/html") - 1;r->headers_out.content_type.data = (u_char * ) "text/html";
20. Creating the actual handler (5)// send the header only, if the request type is http HEADif (r->method == NGX_HTTP_HEAD) { r->headers_out.status = NGX_HTTP_OK; r->headers_out.content_length_n = sizeof(ngx_fun_string) - 1; return ngx_http_send_header(r);}
21. Creating the actual handler (6)// allocate a buffer for your response bodyb = ngx_pcalloc(r->pool, sizeof(ngx_buf_t));if (b == NULL) { return NGX_HTTP_INTERNAL_SERVER_ERROR;}
22. Creating the actual handler (7)// attach this buffer to the buffer chainout.buf = b;out.next = NULL;
23. Creating the actual handler (8)// adjust the pointers of the bufferb->pos = ngx_fun_string;b->last = ngx_fun_string + sizeof(ngx_fun_string) - 1;b->memory = 1; // This buffer is in read-only memory // This means that filters should copy it, and not try to rewrite in place.b->last_buf = 1; // this is the last buffer in the buffer chain
24. Creating the actual handler (9)// set the status liner->headers_out.status = NGX_HTTP_OK;r->headers_out.content_length_n = sizeof(ngx_fun_string) - 1;
25. Creating the actual handler (10) // send the headers of your response rc = ngx_http_send_header(r); if (rc == NGX_ERROR || rc > NGX_OK || r->header_only) { return rc; } // send the buffer chain of your response return ngx_http_output_filter(r, &out);}... almost done!
26. Attaching the handlerstatic char *ngx_http_fun(ngx_conf_t * cf, ngx_command_t * cmd, void * conf){ ngx_http_core_loc_conf_t * clcf; clcf = ngx_http_conf_get_module_loc_conf(cf, ngx_http_core_module); clcf->handler = ngx_http_fun_handler; // handler to process the fun directive return NGX_CONF_OK;}In this function, we can validate on the incomingngx_command_t, and attach different handlers.
27. Does this really work?Trygve will attempt to demonstrate.# make# sudo make installUpdate the nginx-configuration with a location handler,something like this:Location: /fun { fun;}Start nginx, and access http://localhost/fun/
28. Of course it worked! But static text isnt any funStep 2: Update the module to use an external library forcontent creation
29. What are we going to do? Tell me now!•Were going to replace the static text with an image, dynamically created with libcairo.•Were going to learn about buffers and chains
30. The config file - dependency handlingTesting for dependencies is done with the feature testsprovided by nginxngx_feature="cairo"ngx_feature_name=ngx_feature_run=nongx_feature_incs="#include <cairo.h>"ngx_feature_path="/usr/include/cairo"ngx_feature_libs=-lcairongx_feature_test="cairo_version()". auto/featureif [ $ngx_found = yes ]; then ngx_addon_name=ngx_http_fun_module HTTP_MODULES="$HTTP_MODULES ngx_http_fun_module" NGX_ADDON_SRCS="$NGX_ADDON_SRCS $ngx_addon_dir/ngx_http_fun_module.c" CORE_LIBS="$CORE_LIBS `pkg-config cairo cairo-png --libs`" CFLAGS="$CFLAGS `pkg-config cairo cairo-png --cflags`"else cat << END$0: error: the fun module requires the cairo library.END exit 1fi
31. The Cairo part (1)Include the header, and define M_PI#include <cairo.h>#define M_PI 3.14159265struct closure { ngx_http_request_t * r; ngx_chain_t * chain; uint32_t length;};The struct will be used by a callback function were going tocreate later.Throw away ngx_fun_string while youre at it, were not going tobe using that.
32. The Cairo part (2)In ngx_http_fun_handler(), remove the ngx_buf_t (well do thesethings in a callback function later), and add our struct.static ngx_int_tngx_http_fun_handler(ngx_http_request_t * r){ ngx_int_t rc; ngx_chain_t out; struct closure c = { r, &out, 0 };
33. The Cairo part (3)Remove our header-handling from before - we wont be able tocalculate content-length before weve created the png.// set the Content-type headerr->headers_out.content_type_len = sizeof("text/html") - 1;r->headers_out.content_type.len = sizeof("text/html") - 1;r->headers_out.content_type.data = (u_char * ) "text/html";// send the header only, if the request type is http HEADif (r->method == NGX_HTTP_HEAD) { r->headers_out.status = NGX_HTTP_OK; r->headers_out.content_length_n = sizeof(ngx_fun_string) - 1; return ngx_http_send_header(r);}// allocate a buffer for your response bodyb = ngx_pcalloc(r->pool, sizeof(ngx_buf_t));if (b == NULL) { return NGX_HTTP_INTERNAL_SERVER_ERROR;}
34. The Cairo part (4)This is basically ripped from one of their many examples ontheir web page.cairo_surface_t * surface;cairo_t * cr;surface = cairo_image_surface_create (CAIRO_FORMAT_ARGB32, 256, 256);cr = cairo_create (surface);double xc = 128.0;double yc = 128.0;double radius = 100.0;double angle1 = 270.0 * (M_PI/180.0); // angles are specifieddouble angle2 = 180.0 * (M_PI/180.0); // in radians
35. The Cairo part (5)cairo_set_line_width (cr, 10.0);cairo_arc (cr, xc, yc, radius, angle1, angle2);cairo_stroke (cr);// draw helping linescairo_set_source_rgba (cr, 1, 0.2, 0.2, 0.6);cairo_set_line_width (cr, 6.0);cairo_arc (cr, xc, yc, 10.0, 0, 2*M_PI);cairo_fill (cr);cairo_arc (cr, xc, yc, radius, angle1, angle1);cairo_line_to (cr, xc, yc);cairo_arc (cr, xc, yc, radius, angle2, angle2);cairo_line_to (cr, xc, yc);cairo_stroke (cr);
36. The Cairo part (6)Make sure that our buffer chain is NULLed. Remove anyreferences to the ngx_buf_t from earlier.out.buf = NULL;out.next = NULL;// Copy the png image to our buffer chain (we provide our own callback-function)rc = cairo_surface_write_to_png_stream(surface, copy_png_to_chain, &c);// Free cairo stuff.cairo_destroy(cr);cairo_surface_destroy(surface);// If we for some reason didnt manage to copy the png to our buffer, throw 503.if ( rc != CAIRO_STATUS_SUCCESS ){ return NGX_HTTP_INTERNAL_SERVER_ERROR;}The cairo_surface_write_to_png_stream uses a callback-functionto copy the png-data to a buffer, in the way we want.Remember to free resources, and check that everything wentwell.
37. The Cairo part (7)Were going to set our headers now. New content-type - thelength has been calculated by our callback function and isstored in our struct.// set the Content-type headerr->headers_out.content_type_len = sizeof("image/png") - 1;r->headers_out.content_type.len = sizeof("image/png") - 1;r->headers_out.content_type.data = (u_char * ) "image/png";// set the status liner->headers_out.status = NGX_HTTP_OK;r->headers_out.content_length_n = c.length;// send the headers of your responserc = ngx_http_send_header(r);// Weve added the NGX_HTTP_HEAD check here, because were unable to set content length before// weve actually calculated it (which is done by generating the image).// This is a waste of resources, and is why caching solutions exist.if (rc == NGX_ERROR || rc > NGX_OK || r->header_only || r->method == NGX_HTTP_HEAD) { return rc;}
38. Allocating memory in an nginx-module•Nginx has its own memory management system.•ngx_pcalloc(pool, amount) will give you a pointer to some memory you can do what you want with.•pool attaches the memory to an owner. Some memory will be allocated for the request (ngx_http_request_t->pool), and some will be allocated for the module configuration (ngx_conf_t->pool).•Nginx deals with freeing/reusing this memory when its owner doesnt need it anymore.
39. How does buffers and chains work?•ngx_chain_t is a linked list of ngx_buf_ts.•You provide a pointer to the first ngx_chain_t in the chain to ngx_http_output_filter()•It will walk through the chain, and pass all the buffers to the output filter•You need to get comfortable with this, or attaching bits and pieces together will be tricky.
40. Forgot what a linked list is?struct element { int value; struct element * next;};A linked list is typically a struct, referencing an element of itsown type. The last element is often set to NULL, but they canalso be circular, or double (having an additional reference forthe previous item in the list), etc.
41. Creating our callback function (1)Cairo provides you with an interface for accessing png-imageshowever youd like. What we want to do, is to attach them toour chain. We do that by implementing our own callbackfunction. This function will be called an undefined number oftimes.static cairo_status_tcopy_png_to_chain(void * closure, const unsigned char * data, unsigned int length){ // closure is a struct closure struct closure * c = closure; // Just a helper pointer, to help us traverse the linked list. ngx_chain_t * ch = c->chain; // We track the size of the png-file in our closure struct. c->length += length;
42. Creating our callback function (2)// The allocated memory belongs to the request-pool.ngx_buf_t * b = ngx_pcalloc(c->r->pool, sizeof(ngx_buf_t));unsigned char * d = ngx_pcalloc(c->r->pool, length);// We make sure to fail if were unable to allocate memory.if (b == NULL || d == NULL) { return CAIRO_STATUS_NO_MEMORY;}// Copy data to our new buffer, and set the pointers.ngx_memcpy(d, data, length);b->pos = d;b->last = d + length;b->memory = 1;b->last_buf = 1;
43. Creating our callback function (3)If the first element isnt put into place, we can quit early.// Handle the first element in our linked list.if ( c->chain->buf == NULL ){ c->chain->buf = b; return CAIRO_STATUS_SUCCESS;}
44. Creating our callback function (4)// Skip to the end of the linked list.while ( ch->next ){ ch = ch->next;}
45. Creating our callback function (5) // Allocate a new link in our chain. ch->next = ngx_pcalloc(c->r->pool, sizeof(ngx_chain_t)); if ( ch->next == NULL ) { return CAIRO_STATUS_NO_MEMORY; } // Attach our buffer at the end. ch->next->buf = b; ch->next->next = NULL; return CAIRO_STATUS_SUCCESS;}Presto! That was easy :)
46. Were ready to test this out!Fingers crossed.
47. Yeah, but what if I want to be able to configuremy module?•Step 3: Give your module its own configuration directives
48. Create a datatype for config-storagetypedef struct { ngx_uint_t radius;} ngx_http_fun_loc_conf_t;
49. Extend the ngx_http_fun_commands[]-array{ // New parameter: "fun_radius": ngx_string("fun_radius"), // Can be specified on the main level of the config, // can be specified in the server level of the config, // can be specified in the location level of the config, // the directive takes 1 argument (NGX_CONF_TAKE1) NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1, // A builtin function for setting numeric variables ngx_conf_set_num_slot, // We tell nginx how were storing the config. NGX_HTTP_LOC_CONF_OFFSET, offsetof(ngx_http_fun_loc_conf_t, radius), NULL},
50. Create a function for dealing with the configcreationstatic void *ngx_http_fun_create_loc_conf(ngx_conf_t * cf){ ngx_http_fun_loc_conf_t * conf; conf = ngx_pcalloc(cf->pool, sizeof(ngx_http_fun_loc_conf_t)); if (conf == NULL) { return NGX_CONF_ERROR; } conf->radius = NGX_CONF_UNSET_UINT; return conf;}
51. Create a function for merging configstatic char *ngx_http_fun_merge_loc_conf(ngx_conf_t * cf, void * parent, void * child){ ngx_http_fun_loc_conf_t * prev = parent; ngx_http_fun_loc_conf_t * conf = child; ngx_conf_merge_uint_value(conf->radius, prev->radius, 100); if (conf->radius < 1) { ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, "radius must be equal or more than 1"); return NGX_CONF_ERROR; } if (conf->radius > 1000 ) { ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, "radius must be equal or less than 1000"); return NGX_CONF_ERROR; } return NGX_CONF_OK;}
52. Add pointers to our new function in thengx_htt_fun_module_ctxngx_http_fun_create_loc_conf, // create location configurationngx_http_fun_merge_loc_conf // merge location configuration
53. Give our handler access to the configurationdatangx_http_fun_loc_conf_t * cglcf;cglcf = ngx_http_get_module_loc_conf(r, ngx_http_fun_module);
54. Using the config-data in our moduleWe override the dimensions of our image, and we override thecenter-position.surface = cairo_image_surface_create (CAIRO_FORMAT_ARGB32, cglcf->radius*2 + 64, cglcf->radius*2 + 64);cr = cairo_create (surface);double xc = cglcf->radius + 32;double yc = cglcf->radius + 32;double radius = cglcf->radius;
55. It cant possibly be that easy! Show me!Update the configuration to something like this:Location: /funbig { fun; fun_radius 500;}Location: /funsmall { fun; fun_radius 50;}The different URLs result in different sized images.
56. I want to deal with user-input•Step 4: Fetching arguments from the URL
57. This is as easy as parsing strings in C. coughThe request has an uri-element, with members .data and .len.Adding something like this to your handle will give you the 3last characters of the URI as an integer;char * uri;int angle = 0;if ( r->uri.len > 3 ){ uri = (char * )r->uri.data + r->uri.len - 3; angle = strtol(uri, NULL, 10);}
58. Which you then can use ...double angle1 = 0.0; // angles are specifieddouble angle2 = angle * (M_PI/180.0); // in radians
59. Lets have a look at this too!Last demo.
60. References•http://www.evanmiller.org/nginx-modules-guide.html•The nginx source code.•http://blog.zhuzhaoyuan.com/•http://www.nginxguts.com/
61. Thats it!